programming methodologies CS106A:
---------------------------------
lecture 1:
    programming methodologies is about good software engineering principles. Its not just learning the syntax.
    Java is the chosen language for this course.
    Being a good programmer is like learning to write good essays, and just knowing a language doesn't make you a good essay writer. Being a good essay writer makes you a good essay writer.
    "sometimes you have to unlearn what you have learned" ~Yoda, you sometimes pick really bad habits, and it is harder to become an essay writer from being an essay writer than from being a bad essay writer to being a good essay writer.
    english<> a program that makes you weep, it is so good that i gotta show it to somebody.
    english<> it was a wrong call.
    english<> i dig honesty.
    bug in a program : an error in a program. Debugging is removing the bugs.
    learning a language doesn't make you great software engineer. You can learn general syntax of programming languages and then focus on software engineering principles.

lecture 2:
    naming: camelCase for variables and methods.
    methods: a code that we can call/invoke. eg move() , turnLeft()  etc 
    there are many ways to solve a problem.
    you get a problem, you come up with the algorithm to solve it, you code the algorithm and you get your program.
    use tabs for the body of the method to increase readabiltity. you also tab methods in a class.
    class names in PascalCase
    semicolon means an end of instruction.
    you can create turnRight method by using turnLeft method three times in it.
    you can put methods below main in java and call them in main unlike C/C++.
    for loop: to do something repeatedly for n number of times.
        for(int i=0; i<3; i++) {   //put spaces after ;
            do something
        }
    while loop: to do something continuously until some condition is met.
        while(condition) {
            do something
        }
    
    conditionals:
        if(condition) {

        }
        else if(condition) {

        }
        else {

        }
        //you can use if without elses.
        //you can nest loops and conditionals.
    
    programming is not about writing programs that computers understand, programming is about writing programs that people understand. Write you main like a pseudocode and keep breaking those instructions into methods(top down approach).

    think about generalizing your program, so that i solves any kind of problem of that kind.

lecture 3:
    common errors:
        infinite loop: when you never get out of loop.
        off by one bug: obob, you forget to do one more time then you needed to, or you did one more than needed.
        //put comments for other people  /* */ or // , comments are not compiled.
        it is perfectly fine to have one line methods.
        decomposition: breaking big methods into smaller until you don't get to primitives, it is called stepwise refinement. It is also called top down design. In bottom up design you start from primitives and then build bigger.
        english<> denied everytime.
        call high level methods like pseduocode and then code those methods.
        decomposition makes it easier to modify your code.
    decomposition:
        solve one problem at a time to break it down.
        rough guidelines: method should be less than 15 lines.
        and comment the methods, that what they are doing.
        you can use both top down and bottom up simultaneously to solve a problem, like if you know how to do a part, you can just code that first, like bottom up, and then use top down as usual.

lecture 4:
    charles babbage came up with difference engine, and then he designed analytic engine. An analytic engine is as good as modern day turing machine.
    1930's 40's prototypes of computers were build.
    1946 ENIAC.
    1971 first microprocessor.
    computer science is not programming.
    CS is the study of problem solving with computational methods. Programming is just the part of process. Computer science is as much about programming as astronomy is about building telecopes.
    you write source code, then compiler converts it to object code, you link libraries and execute the executable file.
    in Java linker gives you a JAR file and then JVM executes it. JVM makes java platform independent, and there is JVM for all platforms.
    Java is object oriented langauge, and the program is written as a bunch of classes. And a class is encapsulation of behaviour and data for some aspect of your program. Classes get organised in hierarchies, where one class extends another, it is called inheritance, there would be parent class and child/sub class just like hierarchies in biology. You inherit all abilities of your parent. Instance of a class is particular example of that class, eg John is an instance of human. Classes are templates for objects. And these objects interact with each other.
    Graphics:
        collage model:
            you put objects of different shapes and sizes on a canvas.
    new keyword is used to create an object of a class.

lecture 5:
    variable: a box in memory where you stick stuff and modify it, it has some name that you use to refer it and it has a type that tells what is stored in that box and the value in that box.
    valid names start with letter or underscore, spaces are not allowed, also reserved words are not allowed. Make your name descriptive, eg balance, isEligible.
    primitve types: built in java and their name refers to their value , eg int for integer, double for real valued numeric values, it is called double because it has double precision. boolean is true or false, char is for character. for "How much" use double, for "How many" use integers.
    declaring variables: type name = value; eg int x = 3;
    it puts that value somewhere in memory.
    you can declare variables anywhere.
    you can assign an expression to a variable.
    total = total + 1; in cs it means assign right hand side to left hand side, it doesn't mean equality.
    you can assign objects to variables and call methods of it.
    upper left corner is origin in Graphics and measurements are done in pixels.
    constructor is a factory that is used to create new object with initial parameters.
    not specifying the object while calling a method would look for that method in the same class where it is called.
    an expression returns a value.

lecture 6:
    modulo is only for integers.
    division is different, if both are integers, it does integer division. For real values it gives real output.
    you can cast one type to another. eg (double) x/2; first it would take double and then divide by 2 now there won't be any truncation.
    (int)0.99999 is 0.
    you can't assign a double to an int.
    english<> left unchecked. nothing short of a miracle. I wasn't planning on it.
    x--;x++; x+=2; etc are shorthands.
    constant: a variable whose value cannot be changed, eg PI. You force value to not change.
    private means to keep variables to ourselves. static means it lives for whole class. final/const means it is final value or costant. eg private static final double PI = 3.14;
    give good names to your variables. Think of readable names.
    booleans can be either true or false. eg 3>5, relational operations give boolean output.
    ! is called bang.
    ! is not for boolean expresson, && is and and || is or.
    short circuit evaulation: stop evaluvating boolean expression as soon as we know the answer.
        use case, if you want to divide by zero eg p= (x!=0) && ((y/x)==0);
        this way we avoid dividing by 0.
        this is called guard in programming.

    A compound statement(block) is a set of statements enclosed in braces.
        eg { int a=3; y=x;}
        variables die and they live in the block they are defined that is their scope.
        they are also alive in inner scopes.

    if (condition){ }
    else if (condition){ }
    else { }

    if you have only one statement, you can skip braces.
    better, if you always use braces.

    if else if is just if else where else is followed by if block.

    switch case is only for integer like values.

    for loops:   for(init; condition; step){ statements }
    init is done once at the start of loop.
    while loops: while (condition){ statements }

lecture 7:
    cast<> typecasting.
    always use explicit cast (double) integer.
    while loop is an indefinite loop, where you don't know how many times you want to do it.

    in computer programming we hate duplicate code.
    break inside loops reduce readabiltity, as it is hard to check when it will come out.
    you can interchange while and for loops. But generally when we don't know number of iteratoions, we use while.
    i,j,k are used very often in nested loops.
    in 2D array (i+j)%2 can be used to create checkerboard like pattern.

    methods:
        information hiding and abstraction.
        it does what it does, without i making effort to know how.
        object.method(arguments)
        you invoke or call a method.

        method declaration:
            visibility type name(parameters){ body}
            visibility can be public or private, private means only other methods within class can see it.
            type means the return type, it can be void if nothing is returned.
            return statement is what is returned from a method.

            eg private double feetToInches(double feet){
                return 12*feet;
            }
            predicate method: returns a boolean, also called a relation.
        your methods can return objects.
    
lecture 8:
    information hiding: software engineering principle, you don't want person to worry about the internals of that method. You get only what you want. And everyone uses it as a black box, and you can change the interal implementation easily, if you don't change the interface.
    local variable: variable within a method.
    you can have variables with same name in different scopes.
    stack: contains all function calls.
    stackframe: a box for each function call in stack.
    primitive data types are passed by value.
    pesudo random numbers: computer process generates random numbers which are determininstic.
    instance variables are shared by all methods in a class, in contrast to local variables.
    local variables are declared in a method and instance variables are declared in a class.
    they live as long as object lives.

lecture 9:
    Strings:
        it is a data type, you can declare variables of it. It holds a string of characters, it is represented by double quotes. String str = "hello there".
        concatenation using +
    
    writing your own classes:
        general form:
            public class NameOfClass extends SuperClass{
                instance variables and methods.
            }
            by defualt you extend Object class.
            create a new file, and its name should be ClassName.java 
            methods and instance variables can be public or private.
            private can be accessed only within the class.
            most things in class will be private unless it is necessary to make them public.

        a package is a set of classes.
        constructor is a method that is called to initialze everything, it doesn't return a value, its name is same as the name of the class.
            public class Mycounter{
                public Mycounter(int startValue){
                    counter=startValue;
                }
                public Mycounter(){
                    counter=1;
                }
                public int nextValue(){
                    int temp=counter;
                    counter++;
                    return temp;
                }
                private int counter;
            }
            you can have multiple constructors.
            constructor doesn't return anything.
            Name of the class is the name of the constructor.
            It is called when an object is created, instance variables are created before it.
            if name of argument is same as the name of instance variable, then the method would refer to local variable, that is the argument, so to refer to instance variable in that case use this.instanceVariableName.
            this is called shadowing: that is computer first checks if we have local variable of that name.
            "this" refers to recieving object.
            better use distinct names, that way the reader has to think less.
            you should have comment for the class, and for each method.

            creating objects:
                Counter c= new Counter(3);
                    new creates new object, and it invokes the constructor.
            when you pass object, you are not passing a copy, you are passing a reference. Hence the object itself.

            so far we have seen instance variables and local variables, but there are also class variables shared by whole class, and all its instances.
            class variables:
                public static counter=0;
                private static counter=0;
                eg public static PI=3.141592;
                you can initialize them with constructor as well.

    Java Doc:
        /**
            */ java doc commeent.
        special "tags" @param, @result, @return etc.

        eg for a method.

        /**
         * Sets the number of units earned.
         * @param units: The number of units earned 
         */
         public void setUnits(double units){
             unitsEarned = units;
         }
         computer produces nice documentation from these comments. It can produce HTML.
    public final TOTAL =180; //CONSTANT.    
    predcate method returns a boolean.

lecture 10:
    you have getters and setters, name starts as getSomething, setSomething.
    toString method should be in every class, that tells something about the object and it is what will be printed.
    public String toString(){
        return studentName+" "+studentID);
    }

    extending classes:
        having properties of the parent and maybe something else on top of that.
        eg Fresher can extend Student.

        public class Frosh extends Student{
            public Frosh(String name, int id){
                super(name,id); //calls Student constructor
                seUnits(0);
            }
        }

        you have call constructor of regular student first using super.
        super means, call the constructor of parent class.
        you can create toString method here and it will Override that of your parent.
        the subclass doesn't have direct access to private elements. Those variables exist for you as well, but you have to use getters, and setters to access them.
        to set them initally, you use super method as parent constructor.
        You can access public elements directly.

    Graphics:
        collage model:
            create image by adding objects to a canvas.
            newer objects obscure those added earlier.
            layering is called the stacking order or z-order.
        there are graphics packages in java.

    Interfaces(in java): set of methods, and set of classes that have those set of methods.
        eg Resizable, Callable etc 
    

lecture 11:
    gif= gee if.
    jpeg= jay peg.
    event driven programming: event happens and program runs something in response.
    eg when clicking the mouse, or pressing the key, or typing.
    you have listner for event.
    you can have mouse listner, key listner etc. and Java has a package for it.
    so far everything was synchronous.
    now we go to the realm of asynchornous, things don't happen in order, something triggers something else.
    example, mouseClicked(), mouseReleased(), etc 
    keyTyped(),keyReleased() etc 

lecture 12:
    enumerations:
        you refer something through numbers.
        a set of things that you enumerate.
        a set of items that go together and you give them each a number.
        eg fresh=1. soph=2,jr=3,sr=4,grad=5.

    char:
        it is a primitive type.
        char: care or char.
        it is just a character.
        char ch;
        you assign something inside single quote 'a', double quotes is  a string.
        it is always a single letter.
        computer treats them as enumerations, they happen to be numbers.
        number 0 is not same as character '0'.
        A is 65.
        even \n is a character \t is also and so is \0
        to write ' you write '\'' it is called escape character,'\\' for back slash.
        escape character is a character with alternate meaning, they start with \

        char ch = str.charAt(0) to get character from a string.

        you can do math on characters:

        public char toLowerCase(char ch){
            return ch -'A' + 'a';
        } 
        characters are primitives, they don't have a class.
        But there is Character class, it has some static methods.
        ch = Character.toUpperCase(ch);

    Strings:
        it is a class, and you can create objects.
        String str = "hello world";
        String is immutable, that is you cannot change it inplace.
        String methods always give new string as String is immutable, you it cannot change in place.
        str=str.toLowerCase();
        a string can be a single character long.
        you can have zero length string as well.
        you cannot directly compare strings, since they are reference types.
        s1.equals(s2) this returns true or false.
        str.length(),str,charAt(3),str.substring(3,7) [3,7) 
        str.compareTo(s2) returns an integer.
        str.indexOf("hello") it gives index of first instance.

lecture 13:
    tokens are strings delimited by space.
    tokens and words are no same.
    method names for class like, boolean hasMoreTokens(), String nextToken().

lecture 14:
    Memory:
        kilo is 1024=2^10 in cs.
        mega is 2^20
        giga is 2^30
        tera is 2^40
        then there is peta, exa, zetta,yotta.
        all printed material ever 200PB
        hexadecimal is base 16.
        memory is a bunch of cells, each has a location/address. These addresses start with 0 and end till the size of the memory, and we represent it in hexadecimal.
        static variables and constants/special are stored in special location.
        dynamic variables(created using new) are stored in heap. There is garbage collector for them.
        local variables are stored in stack. They are popped when the method ends.

                                        static/special
                                        
                                        heap(heap grows)
                                         V
                                         ^
                                        stack(stack grows)
        stack is on higher addresses eg FFFF 
        if they overlap, they start writing on each other. And your machine crashes.

        different kinds of variables have different size of space associated with them.
            int 4 bytes 
            char 2 bytes

        when you create an object of class:
            it is created in heap.
            new would put place for all instance variables, and then constructor would initialize them.
            in stack there is just the address of that object in heap. And this remains in stack.
            when they call methods of any object they are pushed on the common stack for whole program.
            each call on the stack is called the stack frame.
            the address is the local variable but the object is dynamic variable.
            if you don't saw new then it is primitive type and it stays only on stack and nothing to do with heap there.
            you can have objects on the heap that have referece to other objects on the heap.
            an object can have multiple references, and each reference is capable of manipulating that object.

lecture 15:
    by defualt pointers point to null.
    There are also classes for integers, Integer for int, Double for double, Boolean for boolean, Character for char. These classes are also immutable.

    Files:
        read and create files.
        files are read sequentially from begining till end.
        opening a file: associating a buffer reader object with the file.
        read the file line boy line.
        close the file.
        java.io.* package for it.
        BufferedReader rd = new BufferedReader( new FileReader("students.txt"));
        FileReader associates itself with a particular object in disk.
        BufferedReader asks for line by line.
        while(true){
            String line=rd.readLine();
            if (line==null) break;
        }
        rd.close();

        at the end of file, it returns null, it cannot return empty line as the middle line could be empty.

        If there is no such file, you get an exception.
    
    Exception:
        "throws" an exception.
        exception is problem that stops the normal flow of program.
        some code would catch the exception and handle.
        try{
            risky code/ code for file access and reading and closing.
        }
        catch (IOException ex){
            how to deal with this exception.
        }
        even when you read a file, put it in a try block as things can crash in the middle. And also close it in the try block.
        throwing new exception 
            throw new ErroException("hello there");
            one who called me will handle this

        In the same way, you can write files.
            open, write, close.
        
lecture 16:
    ARRAY:
        ordered, homogeneous.
        type[] name = new type[size] //it is reference type.
        int[] arr = new int[5];
        it is contiguous space in memory, indexed from 0 to n-1 
        they get initialized by whatever is default for that type. For int that would be 0.
        arr[0]=1; //to access particular element.
        you can have array of reference types as well.
        String[] strings= new String[5];
        the size of array is fixed.
        turns out x++ is a method. And it returns the value of x and it then increment the value by 1.
        ++x would increment x by 1 and then return the new value.
        these are called post and preincrement operations.
        actual size of array: how much memory it is using.
        effective size of array: how much of it, am i using.
        giving array as parameter int sum(int[] arr){}
        arr.length gives length of arrays, it is internal public variable.
        arrays are passed as reference, hence no copying.
    ArrayList:
        dynamic arrays.
        it is in java.util.
            ArrayList<String> strlist= new ArrayList<String>(); //it is a template/generic 

lecture 17:
    you can have multi-dimentional arrays/ matrices.
    int[][] arr = new int[3][4];
    it would be array of arrays. that is arr[0] would give you first row as an array. But you cannot pull put a column this way.

    ArrayList is a template/generic. That means it has parametrized type, the type is decidec by one of the parameter.
        methods inside would like like, boolean add(<T> element){}
        it is template as <T> is like a hole that you fill by your parameter.
    ArrayList<String> strList = new ArrayList<String>();
    to give ArrayList you parameter public void add(ArrayList list){}
    ArrayList can only hold objects, it cannot hold primitives. But since we have wrapper classes for primitives we can use them.
    Integer x = new Integer(some int);
    int z = y.intValue();
    going from int to Integer is called boxing, and the reverse is called unboxing.
    from java 5.0 onwards, it happens automatically.

lecture 18:
    in 2D arrays arr[0] would return first row.
    int[][] scores; //this is just declartion, its value is null, it is not yet initilaized.
    we can have 3D arrays as well.

    debugging:

        design  - Architect
        coding  - Engineer 
        Testing - Vandal( what do i need to do to break this program)
        Debugging - detective trying to find what what went wrong.

        design > development > debugging > deployment 
        if you miss problem in one step and it cascades to another, then it would be 10 times costlier to fix it, if it cascades to third step then it would be 100 times costlier. And so on.

        debugging is like a river:
            you can in downstream and you see sewage passing by, and you wonder what is going up.

        what causes bugs:
            bad values of variables.
            faulty logic, you meant it to do x, you coded it to do y.
            unwarranted assumptions, you thought value would be in meters.

        most of the bugs are simple as easy.
        be systematic when debugging, don't be random, trace program instead of just looking.
        have some intuition about what might have went wrong.
        be critical of your code. Even if the code is simple, bug could be as simple as < instead of >
        Don't panic with bugs.
        bug is at one place it doesn't move. You just have to find it.

        println debugging:
            if bad values is the problem, put some println to see value of variables at different stages.
        
        unit testing:
            test individual methods, and debug each one individually.

        modern ide's come with break points, so you can execute your program line by line after a point. It makes debugging easier.
        
lecture 19:
    Interface:
        set of methods, that are common among a set of classes. 
        It is different relationship than inheritance.
        public class A implements InterfaceB{}

    Map:
        key, value pair,
        where key maps to value.
        eg the dictionary.
        HashMap implements Map inteface in java.
        all generics in java would need object and not primitives. Hence you can't put int in hashmap, you need Integer.
        if key not found, you get null.
    
    Iterator:
        list through set of values.
        Iterator<String> it = arr.iterator();
        it.hasNext(), and it.next() are two methods of it.
        you can instead use for loop to go through whole array.

        to use iterator directly:
            for(String name:arr){} //it would call iterator it by its own.
        hashmap has no guaranty of ordering.

lecture 20:
    GUI: graphical user interface.
lecture 21:
    is continuation of GUI 
lecture 22:
    continuation of GUI.
lecture 23:
    in binary search (left+right)/2 would be a bug if left, right are greater than 4 billion as it would overflow.
lecture 24:
    Data Structures:
        Priniciples:
            nouns -> classes 
            verbs -> methods

        shallow copy: when there is only a reference.

lecture 25:
    to create threads, you need a class that implements runnable interface.
lecture 26:
    jar files are like all compiled files put together.
lecture 27:
    programming methodologies course was about programs that work.
    cs106b is about data structures.
    googol 10 to the power 100.

lecture 28:
    just project review.









programming Abstractions CS106B:
------------------------------------
lecture 1:
    this covers, recursion, dynamic data structures, data abstractions like stacks, queues, maps.
    we use C++ for it.
    A working code is not enough.
    english<> my unbiased opinion, in my time here.
    debugging are most awesome detective stories.
    every domain out there can use computer science and construct something cool.
    learning multiple langauges early in your career is good.
    c++ is a super set of C and they fixed certain things.

lecture 2:
    C++ vs Java:
        general syntax is same.
        primitives are same.
        boolean in Java,is called bool in C++.
        #include is analogous to import in Java.
        #include basically says, look for this file and dump its content here.
        <> for standard libarary headers.
        "" for local headers, that are not c++ standards.
        in C++, const int Num_Scores = 4;
        C++ is a hybrid langauge, you can do OOP as well as procedural paradign(functions that do something)
        in Java you can use below method in above method, put in C++ you need to have prototypes. C++ is a topdown read, and it doesn't go back.
        execution starts from main function.
        << strean insertion operator (insert into that stream)
        cout<< "hi there"<<n<<endl;
        you can declare variables anywhere in java and c++.
        return of a main function tells OS if the job was done successfully, like in linux terminal.
        there is definition/prototype and then there is declaration.
        in C++ main has to always return int, unlike C.
        first strategise, how you are going to code, and then code once you have mapped all things out.
        you can give defualt arguments in prototypes.
        c++ user defined types: enumerations (enums)
            enum directionT {North,South,East,West};
            directionT d= East;
            if (d == West){}
            structs:
                struct pointT{double x; dobule y;};
                ; has to be at then end of enums and structs.
        default is pass by value int hi(int x){}
        for pass by reference use &, int hi(int &x){} parameters are now reference to original variable.
        ref helps to avoid copy pasting.

lecture 3:
    library: a bunch of functionalities grouped together.
    header file provides function ptototypes and usage comments.
    compiled library contains implementation.
    eg iostream, string, fstream etc 
    <> for standard headers.
    in every programming langauge there is a graphics library, to build GUI application.
    .h for header files, that contain the prototypes.
    C++ string:
        string s;
        s= "hello there";
        string is a class.
        s.length(), s[i],s[i] can be assigned hence mutable, unlike java.
        empty string by default, as default constructor is called.
        s[1]='a';
        concatenation using +, it is overloaded. 
        you can directly compare using ==, and !=
        functions:
            length(),find( char ch, int pos=0), find(string pattern, int pos=0), find function is overloaded with different ways of using it.
            substr(), replace(),erase(), replace and erase are modifiers or mutators.
    

    variables outside main are global.
    str[i] would give a char.
    use constants instead of magic numbers.
    if you declare functions below, you need to maintain prototypes, and if you change one you need to change another.
    you can also use old style C string. You can convert them to each other.
    string("abc") would give you C++ type string, and a.c_str() would give you C type string from c++ type.
    concatenation only works on C++ type strings and , " " is always treated as C type string initially. hence "abc" + "def" doesn't work, atleast one of them should be C++ type. better use string(" ")+string(" "). Error cases might compile, but they won't give the expected result.
    literal<>value 

lecture 4:
    c++ continued.
lecture 5:



    







programming paradigms:
---------------------------------------------------------------
lecture 1:
    c,assembly,c++,concurrent programming,scheme,Python
    c is procedure oriented,just a hierarchy of functions calling functions/functions.and you manipulate shared data using pointers,procedural programming is a kind of imperative programming. it is verb oriented,i.e function name is a verb saying what it accomplishes.here you have a function and you give some data as an argument,whereas in c++ you go my object arrow do this.the first thing you see is object not a procedure thats why it is object oriented and not procedurally oriented.
    object oriented programming is not just about using classes,it is a way of thinking.
    c and c++ are not even related from the point of view of programming paradigms,they just share the syntax.
    concurrent programming is very useful in networking.there could be synchronization problems with concurrency.
    with functional programming,you rely on return value,but not in C,c++ as using pointers there are very often the side effects.
    scheme is a representative of functional programming.
    with functional programming there must be no side effects.you synthesize partial results and build on top of them.

lecture 2:
    c/c++
    
    data types:
        bool,char,short,int,long,float,double
        short int long are for scalar numbers.
        char for characters.
        bool for boolean.
        double,float for real numbers.

        char is 1 byte,short is 2,int is 4 ,long is 8, float is 4,double is 8.
    
    binary digit -> bit
    technically a bit can be stored in a single bit 0/1
    eight bits is a byte,with 256 possible values.
    in char 'A' is represented as 65 in binary 01000001 that is 2^6 + 1 and that is how you can figure out the rest as well easily,as only second from right is 1. 'a' is 97 as 01100001 two ones after first zero and then 1 from the begining.

    short is 2 bytes there are 2^16 possible values and first bit is sign bit. 0 means positve and 1 means negative.and negative values are stored in 2's complement and sign bit is not complemented.take complement and add 1.to convert a positive number into negative,just make first bit 1 and do 2's complement of the rest.this representation of negative numbers makes addition very easy.just add like decimals.

    short and char are compatible, char ch = 'a'; short sh=ch; it would just prepend a byte to it,it is easier to convert smaller data into bigger one,and for bigger to smaller you need type casting.
    and when you typecast short into a char,its most significant byte/second byte is considered and char is always unsigned.

    think of negative numbers in binary like postive numbers except zeros and ones are reversed and counting starts from 1: cool

    when you convert int into short,it would just copy last 2 bytes or give error.sign is undeterministic but for short to int sign is preserved as it can see the first bit and copy that bit for the rest.
    all 1's is a -1 in binary.

    for floating point representation:
        given a 32 bit pattern
            first bit is sign bit.
            next eight bits are unsighned int representing exponent
            and remaining 23 bits represent the mantissa.
            1.mantissa * 2^(exp-127)
        given a number : to conver it into floating point just keep dividing by 2 to get the form 1.mantissa * 2^(exp-127)

        same for double,you get 1,11,52 and in substraction use -1024.

        when you assign an int to a float,it has to evaulate and invent new bit pattern.and 5 is represented as 5.0 and hence 1.25 * 2^2 
        float f=*(float *)&i; where i was an int,this can be used to evaulate an integer as a float.eg. 37 as int would be almost 0. type convertion of pointer to an integer into a floating point pointer does not effect the integer.
        *(short *)&f; where f is a a float,it would only take first 2 bytes not the last ones. as it would go to the address and read 2 bytes.

lecture 3:
    if you want to read first byte of a double,just point use *(char*)&d;
    if you read a short as a double you would read that short as well as next 6 bytes.
    big endian and little endian has nothing to do with it,it is too low in abstraction level.
    little endian   4 3 2 1   usually the linux mahchines
    big endian      1 2 3 4   windows etc 
    so at byte/physical memory level you would get different results but not at this level of abstraction.

    struct fraction{
        int num;
        int demom;
    };
    struct fraction pi; this would be given 8 contiguous bytes and the address of the struct is coincident with its first field.
    pi.num=22;
    pi.denom=7;

    (fraction *)&(pi.denom) would now treat four bytes of denom and next four bytes as a struct fraction.
    hence pi.denom would be pi.num of this new struct.and its denom would be somewhere else and you could write or override to that value.you can do it in loop to read whole address space of that program.
    
    int array[10];
        it gives 40 contiguous memory locations.
        array is synonymous with address of first locations.
        array[11] you could override something that is not in the array.
        there is no bounds checking in raw arrays in c/c++
        it would even tolerate negative numbers.
        if you want to read whole thing as bytes, you could treat whole thing as a char array and point a char pointer to the begining and start reading the same way.
        array+k  <>  &array[k]
        * is dereference operator.
        *(array+k) <> is same as array[k]

    structs with array inside of them:
        struct student{aq
            char * name; pointer to variable length name is cool.
            char suid[8];
        }
        this is also in contiguous memory one after another,in the order they appear in struct.
    
    array points to first element and adding one moves to next element,doesn't matter how big the size of element is.

    dynamically allocated string in heap is delimited by \0 and you can point to it from anywhere.

    strcpy would also override if more characters given.
    you can even use ptr[3] for a pointer that is not an array it doesn't care and would go to 3rd position from it and start reading or writing.

    empty string is "" is \0 in memory.

    basically c/c++ works at byte level,doesn't matter how big or small an entity,the rules remain same.

lecture 4:
    void swap(void * vp1,void * vp2,int size) void means i don't have knowledge about the pointer type hence making it generic.
    {
        void temp=*vp1; error,as there is no type void.only pointer can be void.
        char buffer[size];gcc allows you to define size that depends on parameter.
        memcpy(buffer,vp1,size); copies size number of bytes from vp1 to buffer.
        memcpy(vp1,vp2,size);
        memcpy(vp2,buffer,size);
    }
    swapping strings is easy and the name is pointers and just exchange the pointers like any two variables.as pointers store the address.
    don't write code that takes void pointers as it is prone to errors unless no other easy way to do it.

    generic linear search:
    we can't do pointer arithmetic on void pointer for example we cannot add 1 to it.
    
    void * lsearch(void * key,void * base,int n,int elemSize)
    {
        for (int i=0;i<n;i++)
        {
            void * elemAddr=(char*)base +i*elemSize; as base is void type and we cannot add anything to it.we can directly assign a pointer to void * as it is like going from more specific to less one.
            if (memcmp(key,elemAddr,elemSize)==0){
                return elemAddr;
            }
        }
        return NULL;
    }

lecture 5:
    a function can take pointer to a function as parameter as well.
    (int x,int (*ptr)(void *,void *)) and all you have to pass is name of the function.
    you can assign void pointer to any other in cpp,as the cast is implicit.
    char * notes[] is not same as char notes[][]; as char * notes[] is memory efficient.
    sizeof char* is same as char** in fact all pointers have same size,we write specific type for readabiltity.
    an array of char * which is basically an array of strings is easy to linearly search.

    if you have double pointer and you want single pointer :   * ( char**)vp1,this could be used to go to any address in memory by just typecasting int * to int ** and then use **ptr to get value of that address.

    you can implement generic data structures as well.
    











data structures: youtube:
    a data structure is a way of organizing data in RAM(as there is a certain way RAM works), so that it can be used effectively.
    they are essential ingredients in creating fast and powerful algorithms.
    They help to manage and organize data.
    They make code cleaner and easier to understand.
    They are an abstraction.

    Abstract Data Type:
        ADT is an abstraction of a data structure which provides only the interface to which a data structure must adhere to.
        The interface does not give any specific details about how something should be implemented or in what programming langauge.
        it is the description of the data structure.
        List is an ADT and Dynamic array and Linked List is the Data structure implementation of them.

    computational complexity: to compute the performance of an operation on a data structure.

    static and dynamic arrays:
        static arrays: indexable, fiexd length.
             can be used for buffers by IO routines.
             can be used to cache answers in dynamic programming.
        dynamic arrays can be implemented using static arrays.
        you can add(),remove(),A[i] the dynamic array.

    singly and doubly linked list:
        a linked list is a sequential list of nodes that hold data which point to other noes also containing data.
        there is a head and tail points to null.
        can be used to implement stack and queue.
        doubly linked list would have pointer to previous node as well.
        you can have circular linked list.
    stack:
        it is a remarkable data structure.
        LIFO data structure.
        push(), pop(), isEmpty(),top().
        used in undo mechanisms, compilers, recursion, DFS on graph.
        BFS uses queue.
        bracket maching can be done using stack.

    Queues:
        FIFO data structure.
        enqueue(),dequeue(),seek(),isEmpty()
        it has front and back.
        enqueue=adding=offering
        dequeue=polling
        can be used for BFS, web servers.
    
    priority queues:
        A priority queue is an Abstract Data type that operates similar to a normal queue except that each element has a certain priority. the priority of the elements in priority queue determine the order in which elements are removed from the PQ.

        This is implemented by Heap.
        A heap is a tree based Ds that satisfies the heap invariant (heap property): if A is a parent node of B then A is ordered with respect to B for all nodes A, B in the heap. i.e the parent node is always greater than the child node for max heap and the tree is almost complete. It can be min heap or max heap. It is binary tree.
        
        used for Dijsktra shortest path, huffman coding, minimum spanning tree.
        you can negative min heap to get max heap, heapify everything.

        implemented using arrays(binary heap)
        add by bubbling up, remove by bubbling down.
        to remove any, remove and swap with the last element and bubble.
    
    