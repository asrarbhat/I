Introduction:
    React is a javascript library for building fast user interfaces.
    developed by facebook, it is the most popular one.
    the other two players are angular and vue.
    at the heart of it is components, a component is a piece of the UI.
    we build independent isolate components and then compose them to build our application.
    every application has one component, which we call root component/ App, it represents the entire application and contains other child components.
    every react application is essentially a tree of components.
    these components are reusable.
    these components are implemented as a class with some state and and a render method.
    state contains the data that what want to display when the component is rendered.
    and the render method is responsible for what the UI should look like.
    React keeps a light weight DOM in memory called the Virtual DOM, and it has React elements in it, this virtual DOM is cheap to create. React checks if something is changed in virtual dom and then it would update a part of real DOM in browser. 
    We no longer have to work with DOM api directly.
    REACT: when the state changes, then react reacts to those changes.
    Angular is a framework and complete solution, but react is just a library.

setting up the system:
    install node, as it comes with npm etc which we need.
    npm i -g create-react-app@1.5.2
        i is for install and -g is for global.
        create-react-app is used to setup the react project.
    in VScode download extentions: simple react snippets, prettier for fomatting and enable format on save.
    create-react-app project1
        it installs react and all third party library needed, like a development server, webpack for bundling, babel for js compilation, so that we don't need to configure things.
        if you want to configure things on your own, then use npm eject
        npm start would launch a development server. at port 3000.

        it creates a few folders, like node_modules for downloaded dependencies.
        public folder for public assets like icon and index.html
        in index.html we have single div with id "root" and it is the container for our react application.

        there is src folder with basic App component.
        that Html like syntax in react is called jsx= javascript xml.
        babel converts jsx into plain js code that browser can understand.
        jsx is not a string, it is a type in itself, and bable converts it into React.createElement("h1","hello world"); or something like that.
        what jsx you return from render method is rendered.
        you can import css files into components like, import "./app.css";
        index.js is entry point for our application.
        registerServiceWorker.js is automatically created by react, it is used for cacheing.
    
    React code from scratch:
        delete everything from source folder.
        create index.js
        import React from 'react';
        import ReactDOM from 'react-dom';

        const element = <h1> hello </h1>
            since bable will replace it with React.createElement we had to import React.
        projects created with create-react-app have hot module reloading so you don't nee to refresh.
        ctrl + shift +I for console. 
        jsx is an Object.
        to render jsx:
            ReactDOM.render(element,document.getElementById("root"))
                //it means render in root element in index.html 
                it would get inserted there after the whole compilation.
        in real world, we would render an App component there.
    
    custom configs:
        in package.json you would see under scripts the commands like start, build, test, eject.
        in create-react-app project, you only have dependencies on react,reat-dom, react-scripts.
        we don't see references to webpack etc under dependencies as those complexcities are hidden.
        npm run eject, and we will see all those dependencies as well.
        now you can see all dependencies under package.json dependencies.
        and we get a config folder as well for configurations.
    
    in js we can use . operation or [] to get property values.
    in react strict mode is enabled by default.
    in javascript function are objects.
    arrow functions do not rebind this, they take it from parent.
    you can use spread operator on objects as well.
    
Components:
    npm start to start the application.
    install bootstrap:
        css library for modern look and feel.
        ctrl + backtick for terminal.
        npm i bootstrap@4.1.1 
        import it in index.js as : import "bootstrap/dist/css/bootstrap.css" 
    
    creating our first component:
        in src folder create components folder
            add counter.jsx there, use camel notation to name files.
            jsx extention comes with better code completion.
            imrc + tab : import React, {Component} from "react";
            cc + tab to create class component.

            class Counter extends Component{
                state={}
                render(){
                    return <h1> hello world </h1>
                }
            }

            export default Counter;

            press esc to stop multi-cursor editing.
            Component class has a bunch of methods that we inherit.
            you have to import React in all modules where you are using jsx expressions.
            as babel compiles them to React.createElement.

        in index.js:
            ctrl + p to have search bar for files so we can switch to them.
            import Counter from "./components/counter";
            ReactDom.render(<Counter/>, document.getElementById("root"));
                babel would replace it with what render method has to return.
            
        jsx expression must have one parent element, as React.createElement takes one argument for element type.
        so enclose such cases with <div> or use <React.Fragment> to avoid creating extra div's 
        put () after return if using multipline, as javascript as automatic semicolon insertion so js might read the whole thing as nothing.
        for multiple cursor editing select a piece of code and keep pressing ctrl + d to keep adding other instances.
    
    embedding expressions:
        state is a special property in react.
        state={
            count:0,
            address={something}
        }
        in render return <h1> {this.state.count} </h1>
        in between {} we can add any javascript expression.

        you can call methods as well.
        you can add methods to your component class.
        formatCount(){
            return this.state.count==0?"zero": this.state.count;
        }

        use object destructing:
            const {count}= this.state;
            now use count instead of this.state.count 
            call this.formatCount();
            you can return a jsx expression as well.
    
    setting attributes:
        you can put image urls in state.
        <img src={this.state.imageUrl} />
        attribute names are like: className as class is already a keyword in javascript.
            className = "badge badge-primary m-2" you can add multiple classes by space separation.
        
        applying styles:
            use classes or style= plain javascript object,
                eg style={{backgroundColor:"green"}}
                or create an object styles in your class and then styles={this.styles}

    rendering classes dynamically:
        just call some function at className={some function} and in that function write the logic for classes.
        eg if count =0 then yellow and otherwise green.
        even in render before the return, you can have logic, infact as much as you want, but don't pollute render, better use separate methods.
    
    rendering lists:
        you got a list of stuff:
            this.state.tags.map(tag=><li key={tag}>{tag}</li>)
            you need key for iterators for react to identify them easily, during re-rendering. it has to be unique, only within the list.
    conditional rendering:
        you can add separate helper method for filtering or conditional rendering.
        if you want nothing you can return null.
        or you can use ternary operation or use logical and &&

    Handling events:
        based on standard dom events:
        like onClick, onKeyUp etc 
        in button onClick={this.handleIncrement}
        create a method:
            handleIncrement(){
                
            }
            in this method "this" doesn't point to the current object. as we are giving it as an input to some other event handler, hence it becomes part of that event handler, hence that event handler would call that method, and by default this references to window.
            to solve this problem:
            create a constructor:
                constructor(){
                    super();
                    this.handleIncrement=this.handleIncrement.bind(this);
                }
            
            or you can use arrow functions as they take this from parent.
            handleIncrement = ()=>{}
        
    updating the state:
        this.state++;
        this.setState(this.state);
        //setState is a method we inherit from Component class.
    
        when the state changes, react schedules an aynchornous call to render method, it will return a new updated react element, react compares new and old virtual dom and figures out what has been modified, and then updates the dom in browser only where it is needed. So whole thing is not rendered again in browser.
    
    passing event arguments:
        onClick={()=>this.handleIncrement(1,2,3)}
        or create a method with no arugment and within it call the handleIncrement method.
        better use inline.
    table.table>thead>tr>th*4 to have a table with class table, instead that thead and inside that tr and inside that 4 th's. This is called zencoding.
    
composing components:
    <Counter key= {id}/>
    passing data to components:
        <Counter key={id} value={this.state.counter.value} selected ={true} /> 
            //by default selected is true so you don't need to put it.
            within that component: 
                this.props
                this is a javascript object within each component.
                within eachc component:
                    count: this.props.value 
    passing children:
        special prop, for when we want to pass something between opening and closing tags of component.
        <Counter>
            <h4> hi there {this could be dynamic}</h4>
        </Counter>

        {this.props.children} to render it.
        key is the one for uniqueness, id is just like any other prop.
    
    download react developer tools extention for chrome and firefox: it is good for debugging.
        in chrome developer tools you will see a tab for react now when you click on >>
        you can see tree of components and you can expand each component.
        you click on component to see props and state.
        this makes visualization easy.
        when you select a component you get $r, type $r on console, you get the whole component printed.
        you can even do $r.render() $r.click() etc.
    
    props vs state:
        state is local and internal.
        props is what you get from other component.
        props are read only. as they are from upper component.
        to change the prop you call the method of upper component, that you get as a prop.
        the component that owns the state, should be the one that modifies it.
        to modify you raise an event to your parent.
        Counter would raise an event and Counters would handle it.
        add new prop to Counter as onDelete= {this.handleDelete}
        key prop is used internally, and you won't be able to access it.
        instead of using separate props, you can pass the whole object, or whole data about that object.
        this.props.counter.count where counter is the whole object.

    single source of truth:
        don't keep a local state, use props to update and read data.
        don't initialize your state using props.
        even the methods to handle handleIncrements etc should also be in parent.
        when two components share data and if they are parent child then lift state to parent or if they  are not parent child, then lift the state to common parent among them.
        just draw and tree to figure out, the events that could be raised and the state that to be created.
        a component that get data as props only and doesn't have a state is called a controlled component.
    
    stateless functional components:
        if there is just a single render method and there is no state, we can convert that into stateless functional component.

        const NavBar=(props)=>{
            return <jsx>
        }
        you don't extend anything.
        some developers prefer functions for stateless components.

        sfc to create stateless functinal component.
        export default NavBar;
        it takes props object as an argument.

        you can use object destructing in render before return, to only have those properties that we need.
    
    Lifecycle hooks:
        our component goes through different phases, and we call call functions at those phases and these phases are called lifecycle hooks.

        mount: when instance of a component is create and inserted in dom.
            constructor(), render() , componentDidMound() called in that order.
        update when state or props change:
            render(), componentDidUpdate() in that order.
        unmount:
            componentWillUnmount() 
        
        there are more, but we rarely need them.
    
        if you class component has constructor then it has to call constructor of parent by putting super() as first line.
        constructor is only called once when the component is created, you can intialize state there 
        using this.state.something you can't use this.setState in constructor as the component hasn't rendered even once before.
        constructor(props){
            super(props)
        }
        you have to get props as argument.
        otherwise you can't access props in constructor.
        now access props using this.props.

        componentDidMound(){
            you can have ajax calls to get data from server.
            then this.setState(new data)
        }
        when a component is rendered, all its children are rendered recursively.
        there are no lifecycle hooks in stateless functional components.

        when there is an update:
            componentDidUpdate(prevProps,prevState){
                //can make ajax calls for updates.
                if no state then value would be null.
            }
        
    unmounting phase:
        componentWillUnmount(){
            //called just before component is removed from dom.
            //can be used for cleanup to avoid memory leaks.
        }

    you can disable a button.

pagination, filtering and sorting:
    before designing a component, think of the inputs that it is gonna recieve, and the best way to decide it is to use it before implementing it.
    eg use <Pagination itemsCount={50} pageSize={4} currentPage={this.state.currentPage} onPageChange={this.handlePageChange} />
    instead href, you can onClick event.
    create a utils folder for all the algorithms.js files like pagination or filtering algorithm.

    type checking with PropTypes:
        npm i prop-types@15.6.2
        in your component:
            iimport PropTypes from 'prop-types';

            after we define pagination:
            add a new property to our component as:
                Pagination.propTypes={
                    itemsCount: PropTypes.number.isRequired,
                    pageSize: PropTypes.number.isRequired
                    onPageChange: PropTypes.func.isRequired  
                };
        now you get an error in brower console.
        this also acts as the documentation.
    
    fewer props means better props.
    you can set default value for props.
        after you define the component:
            ListGroup.defaultProps ={
                textProperty: "name",
                value:"_id"
            }
    
    make sure that that your components, only raise events, put utility methods, within the class so the component is reusable.
    create a commons folder in your components folder for reusable components.
    extract low level stuff into a different component.
    in a file you can create mulitple classes, one can have utility methods, and one is the main component that you would export.
    

Routing:
    

Authentication and Authorization:
    while registering if it registers same again, you can respond with 400 response code and message that says user already registered.
    you can respond whichever way you want.
    200 code means success.
    During login the backend can respond with JWT: jason web token, it is a string.
    we store jwt in local storage, that every browser has.
    const {data: jwt}= await login(whatever);
    localStorage.setItem('token',jwt);
    you can find it in browser ctrl+shift+i in application storage, local storage.
    in http: when you see a header that starts with x it means it is a custom header.
    the server can return jwt in header also, so you might have to read it from there.
    for client to read custom header, the backend has to set access-control-expose-headers and put the headers that client should be able to read there.
    to get the value response.headers['x-auth-token']
    jwt uses sha256

    to get values from localStorage:
        npm i jwt-decode@2.2.0 
        import jwtDecode from 'jwt-decode'
        const jwt=localStorage.getItem('token');
        //a url has only access to token under it.
        jwtDecode(jwt);//it returns current user object.
        you can set state from this.
        wrap it in try catch:
        since if the token is not there it would give an error.
        window.location='/' causes full reload of page.
        localStorage.removeItem('token') to remove it.

    calling protected api's:
        in services file of yours.
        axios.defaults.headers.common['x-auth-token']=your token.
        now with every request this would be added.
        and if tokens is not there, it would give undefined hence header would not be set.
        different kinds of tokens can be given different kinds of access.
        protecting routes: but a condition in route for the component it would render, if user is not logged in then i would redirect else go to the original component.
        you can create a ProtectedRoute component and make it resusedable for all routes that you want to be protected. and check based on data stored in localStorage.
        for redirecting user to page it wanted to go to but it had to login in, watch 21 lecture it is about in login instead of going to homepage check in lacation property if it wanted to go somewhere else.
        in login page, if it is already logged in redirect to somewhere else.






REACT: udemy

React is a javascript library used to create reactive web applications.
You do do by splitting web pages into components, like header, sidebar, content, headline etc
you build these blocks in isolation, and we bet managable web page.
reactjs.org

ReactDOM is about rendering what you created to real dom.
you need babel to convert react code to vanilla js first.
you have to write component names in capital, even if it is a functional component.
jsx in javascript would not work, if you hadn't added babel as a processor.

function Person(props){
    return <div> {props} </div>
}

ReactDOM.render(<Person name="hi" />, document.querySelector('#p'));
<Person/> would be a block level element like all react components.
this is syntactic sugar to call the render method of it.

Why web apps over applications: because you don't want to download thousands of applications.
Two kinds of Applications:
    single page application: only one html page, content is re-rendered on Client, everything is managed by js. No way to send requests for UI to backend. You just parse the route, and re-render.
    Multipage Applications: Multiple Pages, Content is rendered on Server, there are links etc.

The basics:
    bundler like webpack, takes your modules and gives one output file. Web does babel thing and minification also.
    next gen js: ES6 and above.
    yarn is alternative to npm
    npm start to start a development server.
    it has hot module reloading.
    package.json has general dependencies.
    package-lock.json locks the dependencies.
    react the the framework depedency.
    react-dom is for rendering to real dom.
    react-scripts is for development server etc, build, test, eject

    public folder has your single page, that is index.html, you inject everything to it.
    src has index.js that would be the main file that injects to your html file.
    you don't need .js extention while importing.
    but for css file or any other file, you have to write extention eg ".app.css" 
    export default YourComponent
    typically you only use ReactDOM.render once and put one composed component there.

    class App extends Component{
        render(){
            return jsx;
        }
    }
    it inherits from Component
    we need to import React, becuase during compilation, render returns React.createElement('div', null, 'h1', "hi") if you have more components in div you have to pass React.createElement has third argument and so on. the null argument is css styles can put {className: "hi"}
    even though we are not using React directly we still need to import it becuase of above reasons.

    Functional component:
        name your folder in capital for your components.
        usually create a separate folder for each component.
        try to always use ES6 to create functinal components.

        import React, from 'react';
        const Person = ()=>{
            return <p> hello there</p>
        }
        export default Person;
        //you have to use uppercase as lowercase are reserved for inbuilt html.
        you can now use <Person> <Person/> 
        if no children then use <Person/>
    components are highly re-usable.
    to execute javascript in jsx we put it in {}

    working with props:
        to pass data, and make component configurable.

        <Person name="hi" age="29"/>
                import React, from 'react';
        const Person = (props)=>{
            return <p>{props.name}</p>
        }
        export default Person;

        //props means property, you can use anyname though.
        if you pass something as child to a component, to access it use props.children

    to have state within the component and not have it has props.
        within a class you don't create properties like let name= something.
        since it is an object you directly use name = something.

        in class components you can have special property state, as there are methods in Component that would expect this property.

        state = {
            name: "rayon"
        }
        access state using this.state.name
        this refers to current object, or the context of object where we are at.
        if state changes react automatically re renders that component, thats why it is a special component.
        but onClick ={this.switchNameHandler or use this.handleSwitchName}
        use arrow notation to declare your functions within class as otherwise they won't have access to this.state if they are across as in onClick.
        use variable=()=>{}
        don't directly mutate state, use this.setState({})
        this.setState is when react identifies changes and rerenders.
        react hooks: a bunch of functions provided by react.
        react 16.8 and above uses hooks, eg useState to mange state in functional components.
        const [state, modifier funciotn]=useState({current state, could be an object.})
        just put event handlers above return keyword in your functional component.
        useState function replaces the whole state, whereas this.setState modifies.
        better use useState muliple times to get different functions for each value in your state.
        I prefer class based components.
        prefer to use this.functionname.bind(this, arugment) in a function to pass argument instead of ()=> this.functionname(arugment) as the earlier is efficient.
        all event handlers by default take event, or e as an argument.
        e.target.value is the value after every change in it for onChange event. you onChange={props.changed} and changed funciton would have e as an arugment, passed by default.
        to set value for an input element: value={varialble name}

        adding stylesheet:
            just write a css file and import it.
            the css files are not limited to that component, it is global.
            webpack handles it by injecting to html page directly in head, import just makes it aware that such style file exist.

            inline style: just assing style property to a js object.
            better use css files.

Rendering content dynamically.
    you can use if etc in jsx, only simple statements, you can use ternary operatons thought.
    use ternary operations, and if you can nothing to be rendered, then return null.
    {this.condition? <div> </div>:null}
    to turn true to false or false to true: value: !previousValue 
    everything in the render method gets executed when rerendering happens, and not just the return part.
    if there is an array of jsx objects within jsx, then react automatically pulls them out of it in order.
    directly manipulating the state can result in unpredictable errors, even if it works.
    be careful if your copy is a shallow copy.
    key prop is important for renderding list, it helps react update efficiently, which otherwise is highly inefficeint for react.
    so basically without key, it sees whole list as one compnent and doesn't know what changed so it would re-render whole list, which is inefficent if list is long, but if you use keys, ti would treat every element is separate hence in case of changes only those are re rednered.
    key should be unique, don't use index as index would change with change in size or if something removed from list, it does't need to be a number. better have some kind of id in data.
    for event handler with mulitple arugments use (event)=> this.someting(event, arguments)
    Object.assign or spread operator to copy an object.
    instead of conditonally render in jsx, you can create jsx conditionally before return and then use it in jsx. or use separate function.
    basically ask yourself, what belongs where, like in return, or in render above return or in separate function.

styling react components:
    inline styles to limite to that compnent.
    dynamic styling is easir with inline styling object, as you can directly modify it using js.
    to dynamically render a class, just put all applicable classes in a list and you can add and remove to it and join it before return and pass as a property.
    in inline you cannot use pseudo selector like hover. in css you can but it would be globally applied, we can use unique ids but it is nto prefferable. There comes a library to use pseudo selectors inline 
    npm install radium 
        it allows inline styles with pseudo selectors.
        import Radium form 'radium'
        at the end export default Radium(App); //higher order component, component taking other compnent argument. Can use with both functional and class compnent.
        now in inline style put any property within ':hover':{whatever you want to change} you have to use '', it also allows you to use media querties. '@media (min-width:500'):{}
        but for media queries wrap your whatever you return within <StyleRoot> </StyleRoot> compnent by radium 
    
    but i wish there was a way to scope a css file to specific component only.
        we can remove random.
        we can create scoped css files.
        you need to run npm eject.
        we get scripts folder and config folder.
        in config folder go to webpack.config.dev.js 
            under module find css-loader and under options add modules:true, localIdentName: '[name]__[local]__[hash:base64:5]'
        do same for poduction file.
        now in your files your import anyname from './App.css'
        now all your styles are as objects in anyname.class1 or whatever yoru classname is in css file.
        you can assign to your inline class.
        you can also have access to media queries as well this way without needing to do anything.
        same way for pseduo class selectors etc.

Debugging:
    sources in browser shows your files that are there for frontend.
    you can go to sources, and click on line right side to start debugging in browser.
    react developer tools is better.

Component Deep Dive:
    render() method should be lean.
    create a components folder in your src.
    and have index.js in your src folder.
    stateful: could be class or functional, also called container component.
    stateless: presentational component.
    try to have as less components as possible that manage state, that way presentational compnents only show stuff and we know where state is.
    since react 16 even functinal components can have state.
    functional components do not have lifecycle hooks, they have access to state though.
    use class components if you need to manage state or access to lifecycle hooks and you don't want to use react hooks, otherwise use functinal.
    sending props eg appTitle="person"
    lifecycle compnents only available for class components.
        first constructor(props)
                super(props)
                is executed.
                if you have constructor.
                you can use this to setup initial state.
    make sure your methods are not causing infinite re-rendering.
    use this.props in class components.
    you can set state based on props in constructor.
    google or ask chatgpt: i want a function to call when my prop is changed, and it will give you the lifecycle hook etc, this is how you code in react.
    hooks in functional components:
        useState to create a state.
        useEffect:
            all lifecycle hooks in one hook.
            by default it runs for every render cycle, hence as good as componentDidUpdate
            it also runs when compnent is created, hence also as good as componentDidMound
            note: react first checks if it needs to touch the real dom or not.
            it takes second argument as a list and it would only run when your date in array changes.
            if you pass an empty array, it has no dependencies hence it can't rerun hence it would only run the first time.
            componentWillUnmount for cleanup in class components.
            for functinal components return from useEffect an anonymous function that would run everytime component unmounts if it has empty array as arugment, if there is no array as second arugment or non empty, it would run on every time that changes.
            you can use multiple useEffect().

    how react updates dom:
        it compares old virtual Dom and re-rendered virtual dom, and it checks if there are differences, it then only updates places where update are made. real dom is only touched if needed, virtual dom is very fast.
    
    react allows your render to return array as long as they have unique key as array is still a single element, hence if you use commna after each compnent you can return muliple elemnts, but better use React.Fragment.
    hoc: higher order components ones that take other components or returns other componets.
        it can be use to create React.Fragment like element that just returns props.children.
        React.Fragment is a hoc that returns children.
    
    create a separete folder for hoc.
    hoc, just wraps other compnents, or appends anything to it.
    naming convention: WithSomething.
        you take imput as props.children for hoc.
        you can pass multiple components as children.
        if you create a regular function to take compnent as argument, it has to start with capital.
        hence you can create a js function as hoc that takes component as arugment and returns a functional or class component with your arugment compnent and might as well take props if needed.
        you can add logic to your hoc.
        you usually export with hoc in that file.
        {...props is cool}
        setState is asynchornous and it is scheduled.
        when you new state depends on old state.
            use this.setState((prevState,props)=>(
                return{something: someting, a:prevState.changeCounter+1}
            ))
            this solves the problem of it being asynchornous.

    
    to make sure props are being used correctly use proptypes, it is build by react people.
    you add property to your component:
        Person.propTypes={
            click:PropTypes.func,
            name:PropTypes.string
        }
        people would get warngings.
    
    Refs:
        just set ref property in any component.
        ref={(inputEl)=>{this.inputElemment=inputEl}}
        now you can use anywhere this.inputElemment.focus() or anything.
        or better use React.createRef() to create a reference.
        and set ref={this.varialbeNameForRef}
        this.varialbeNameForRef.current gives you ref you can call focus etc on it.
        for functioal compnents.
            const toggleButtonRef=useRef(null);//null is intitial value 
            you can now use it as you want.

    Context: to not pass props via multiple layer if middle layers don't want it.
    const c=React.createContext({
            optional initial value.
    }) 
    export c 
    it is  plain js object.
    wrap your componets which you want to have context to and its children in <AuthoContext.Provider value={{the value for context if you din't pass initial vlaue}}>//the value is a prop and it would update these values in your initial state.

    whereever you want to consume it use .consumer component, if it takes function as a child, that takes context obect as an argument.
    you return your jsx code.

    better way to use in class componets:
        instead of consumer
        add in your class static contextType=AuthConext;
        it allows you to access the data using this.context.whatever, the name has to be contextType
    
    in functional compnents:
        const abc=useContext(AuthContext)
            abc.wahtever now use 
            useContext hook is for functional compnents.
    
    redux also helps us with this.

planning a react application:
    1. plan the component tree/component structure.
    2. application state(data)
    3. components vs containers.

    draw a tree of components on paper.
    summarize state for whole application separately as json object, and then decide what would be put where, always put at the parent of all components where it is needed, all other components should be stateless.
    App compnent is for layout.
    create a folder for each component that starts with capital.
    you can use propTypes on functional components as well.

Http requests in React:
    react and server communicate using json.
    componentDidMount is best place to send http requests.
    axios.anything() returns a promise.
    within then you can call this.setState
    componentDidUpdate can send infinite request, so use a conditional statement in it to send request only once.
    you can use .catch for promise to handle error or use try catch.

    in index.js 
        import axios.
        axios.interceptors.request.use(request=>{
            //make edits
            return request; //you always have to return the request otherwise you are blocking it, all requests go throught this.
        },error=>{
            if error happens.
            return Promise.reject(error);
        })
        can do the same for responses as well.
        you can add headers to requests here for requests that you send, or set some global configurations.
        eg axios.defaults.baseURL("http..com")
        now send request to /posts or something.
        axios.defaults.headers.common["Authorization"]="Auth Token";
        axios.defaults.headers.post['Content-type']="whatever"
        you can create instances of axios to have configuration for specific parts and not others.

Testing React Apps:
    Writing automated tests.
    Writing units tests for apps created using create-react-app
    Testing: build app, test manually, then ship it to server, but we can automate tests after manual tests.
    everytime before we send to server, these tests run.
    or during we build and before manual testing.
    test driven development: write tests before code, all tests fail initially then as you build, tests start to pass.
    we write tests for components.

    Testing tools:
        Test runner: executes our tests and provides validation library.
        we use jest, it comes with create-react-app you can also install it if not here.
        testing utilities: simulates the react app like react test utils, enzyme
    
    What to Test:
        don't test the library, third party libraries etc are not tested.
        you test what you wrote.
        you fake data that you get from database.
        don't test complex connections.
        do test isolated units.
        do test your conditional outputs.

    
    Writing Test:
        make sure npm start is not running.
        npm install jest 
        npm install enzyme react-test-renderer enzyme-adapter-react-16 
        most of functions are functional components and they only depend on props.
        create ComponentName.test.js //has to be this name for command to find it.

            import {configure,shallow} from 'enzyme';
            impor Adapter from 'enzyme-adapter-react-16'
            configure({adapter:new Adapter()});
            import ComponentName form'./componentName';
            improt React from ..
            describe('<ComponentName/>',()=>{
                it('should render two <somecomponent/> elements if not authenticate',()=>{
                        const wrapper=shallow(<componentName/>)//this is shallow renders that is children are not rendered.
                        //now write your expectations.
                        expect(wrapper.find(SomeComponentName).toHaveLength(2));//to have it two times there.
                })//just some meaningful test.

                //enzyme allows us to render just that component.

            })
        defualt exports can be named anything while importing.
        run the test script npm run test.
        copy it function and paste it below first one, and write second test case.
        you can give props directly there to functional components.
        just save and hot module reloading would do the trick.
        there is a beforeEach method that takes a function with no arguments and you can do some ttuff ther and also have a AfterEach is also there.
        for wrapper you can set props using wrapper.setProps({props})

    
    testing class componets would be same assuming redux works perfectly.
    just export your class, even though it is your default export as well, but default export has connect in it so export it separately as well.
    and test it similarly, set props etc as that.

    to test redux:
        reducers are what you want to test.
        reducers are pure functions hence easy to test.
        import reducer.
        and import action tests.
        now write your tests.
        
Hooks:
    from react 16.8
    functional components only take props.
    lifecycle hooks can be hard to use.
    use in useState means it is a hook. we use array destructing with it.
    useState returns an array.
    in hooks you can directly use old state while setting.
    try to use different useState for every varialbe.
    you can only use useState inside your functional component at top level, you can't use it in conditional and you cannot use it in funciton within component.
    useEffect takes a function that runs when component gets for the first time after render.
    keep your render function as clean as possible and as fast as possible.
    keep your things in useEffect
    useEffect runs after render always, if you give second arugment as array, it only render when things in that array change, if you keep it empty it only  runs once.
    if you want to cleanup you can return a function and it would run everytime as well affter the main function in useEffect. you undo stuff you did within the function that you had in useEffect, but it still runs everytime with other funciton, if you give second argument as empty array to this, it would only run when the component gets destroyed.
    
redux:
    there is only one reducer, you merge multiple to one ultimatelly.
    by defualt value of store is undefined.
    you can give intitial state in reducer.
    create store in index.js better.




learning from doing:
    at the end of the day, you whole react app boils down to index.js and bundle.js file.
    css files are added to the head in style element recursively.
    defer boolean attribute is used by react, and it means download the script parallely and run it after the parsing of page is done.
    your whole app is put inside the div with root id.
    but after build, it creates css files and links them, instead of copying to head.
    react dev tools doesn't work on build.
    your bundle contains all your dependencies as well.


    
jest:
    JavaScript Testing Framework.
    It can be used with frontend and backend.
    npm install jest //save as development dependency.

    create file, filename.test.js
                it("should add 1+2 is equal to 3",()=>{
                        const result=sum(1,2);
                        expect(result).toBe(3)//this is called a matcher, there are multiple matchers available.

                })
                you don't need to import it or expect.
                npm run test
            
            you can group related tests in describe.

            describe("name of tests",()=>{
                it("what your test would do",(=>{
                    expect(result).toBe(expected)
                }))
                  it("what your test would do",(=>{
                    expect(result).toBe(expected)
                }))
            })

            to run specific test suite just run that file in node.
            toBe doesn't work for objects equality, but toEqual does.
            expect(n).toBeTruthy() or toBeFalsy() 
            expect(n).not.toBeFalsy();
            you can put multiple expects in a test.
            describe is a test suite.







