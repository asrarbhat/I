Getting started:
    A state management library for javascript apps.
    you can use it with react, angular, vue, or even vanilla js 
    it doesn't care what library you use to build front end.
    other solutions are flux,mobx
    we store everything in a central repository.
    we will get a single source of truth.
    used to synchronize data across components.
    hence redux centralizes application's state.
    redux dev tool extention for chrome is neat. You can jump to certain state of UI from history, it is called time travel debugging.
    state is stored in a javascript object.
    60% react projects are done with redux.
    it is based on functional programming.

Functional programming:
    redux is build on top of functional programming.
    invented in 1950's.
    composing and piping.
    install lodash.
    import compose and pipe from it.
    compose(third, second, first) it returns new function.
    pipe(first, second, third)
    Currying: a function that takes a few argument and returns a function to take other.
    pure function: same argument, same output, it doesn't take dependencies or global variables. Their result can be cached.
    immutablility: you don't update an object, you can create a copy by spread operator. JS objects are not immutablile, immutalbe makes it easy to detect a change, hence makes everything easy. Thats why redux uses it.
    for objects you can use spread operator. but still it will do a shallow, for objects in objects do spread operator for each property, or use some library.
    For arrays we can use spread operator, or use functions like slice, map, filter etc
    Immutable, immer, Mori provide immutable  ds as js objects are not immutable.
    Immer is mostly used.
    Map from immutable library gives you a map.
    it has get method etc.
    toJS() would return js object
    set()  returns new Map.
    
    Immer: 
        produce function in immer.
        Give it a js object, and functions that mutate that object.
        it internally does whole thing, you don't need to worry about anything.
           produce would return the updated object.
           
Redux Fundamentals:
    you store your state in a single javascript object called store.
    it is the single source of truth and is accessible to all components of UI.
    we can't directly modify the store.
    our store is an immutable object.
    so we have to take it as an argument and return updated store.
    such a function is called reducer.
    the reducer takes action as second argument, which is an object which describes what to be changed.
    we can have reducer for each field in store separately.
    reducer is a pure function.
    we do not call reducer directly, we just work with store.
    store calls reducer, and notifies UI component about the update.

    steps:
        design the store.
        define the actions.
        create reducers.
        setup the store.

    npm install redux@4.0

    designing the store:
        to decide what we keep in store.
        eg an object that contains a list called bugs to track bugs, and an object current user to have details of current user.

    defining the actions:
        example add a bug, mark a bug resolved, delete a bug etc 
        an action is just a plain js object that describes what just happened eg an object with two properties, type that describes the type of bug in str, and description as text to describle text value of it.
        type is compulsary property everything else is optional.
        type could be string or number, better use string.
        eg type: "ADD_BUG" use this convention.

    creating a reducer:
        create a file reducer.js 
            lets say state is an array.
            function reducer(state, action){
                if (action.type==='ADD_BUG')
                    return [...state,{new bug}]
                else if (action.type==='REMOVE_BUG'){
                    do your thing here
                }
                return state
            }
            give state a default value so first time there js no state so give empty object or array.

    creating a store:
        create a file store.js 
        import {createStore} from 'redux';
        import reducer from './reducer'

        const store=createStore(reducer);
        export defualt store;
    
    dispatching action:
        import store from './store';
        store is an object with a few inbuild properties.
        there is a method getState, there is no method for setState as you have to dispatch an action for that.
        store.getState() would return an empty array int this case.
        store.dispatch({
            type:'bugAded',
            description: 'whatever'
        })
        //cool 

    subscribing to the store:
        store.subscribe()
        this function gets called everytime the state of the store changes.
        store.subscribe(()=>{
            console.log(whatever)
        })
        we use this to refesh the UI.
        it returns a function unsubscribe that you can use to unsubscribe, when you move to different page.
        unsubscribe();
    
    when we dipatch an action, our store would call the reducer, and update state, and call subscribers methods that we have.
    redux has small api to learn.
    you can create a separete js file for action types so there is just one place to modify from.
    create a function that will create action object for you, call it actionCreator, instead of writing whole thing again and again.
    you can add as much to action as you want.

    you access the internal state using getState, hence internal state is private.

Debugging redux applications:
    install redux devtools extention to chrome.
    you can find it under >> 
    in createStore give the argument needed for the extention. like wondow.something
    it is an amazing tool.
    log monitors shows you logs of all actions taken.

writing clean redux code:
    structuring files and folder:
        UI and state are different so create a different folder for store.
        create a folder store in src, and in it create actions.js, actionTypes.js, and reducer.js 
        the names of your folders should be their role and not the library you are using.

        ducks pattern:
            create a store folder.
            create one store in each file for as as many stores you need.
            eg bugs.js 
                at top //action Types
                    export const BUG_ADDED='bugAdded' //no need to export as they are internal.
                    and so on for all action types 

                    //actions
                        function that returns action object.
                    
                    //reducer 
                        reducer should be your default export.
                    
                    keep a separate file for store in  store folder.

    redux toolkit:
        for simplifying your redux code.
        npm i @reduxjs/toolkit@1.2.5
        it provides a bunch of utility functions to simplifying code.
        import {configureStore} from '@reduxjs.....

        const store = configureStore({redicer});
        //automatically connects to redux dev tools.

        similiary createAction method that takes type and returns a funciotn,and then you call that function with describption to get the action.

        //creating reducers.
        createReducer(initial state, {
            actions: funcitons that handle those actions
        })
        the function would take two paramters:
            (state, action)=>{
                you can write mutating code here 
                underneath it uses inner to make it immutalbe code.
            }


integrate redux into react:
    unmounting component doesn't only mean delete it means not in viewport.
    put unsubscribe in componentwillunmount.
    


