kubernetes crash course for beginnners:

    what is kubernetes?
        open source container orchestration tool.
        developed by google
        helps manage containerized applications in different deployment enviroments.

    what problems does k8 solve ?
        trend from monolith to microservices
        increased usage of containers
        demand for a proper way of managing those hudnreds of containers.

    what features orchestration tools offer?
        high availability or no downtime.
        scalability or high performance.
        disaster recovery-backup and restore.

    
    kubernetes architecture:
        it uses a cluser of atleast one node/machine/virtual machine.

        there is atleast one master node and multiple worker nodes.

        each worker node has a kubelet process running.

        kubelet is used to communicate and do tasks among the cluster.

        each node can running one or more docker containers.

        master node runs processes to manage the cluster,like api server=>it is also a container which is entry point to k8 cluster.it also runs controller manager which keeps track of the cluster.
        it also has scheduler container,which decides on which worker node should take next container.
        etcd=k8 backing store,it stores state of cluster at any time,it has all configuration data and state data,it is used for backup. etcd snapshot is used for recovery.

        cluster is connected by a virtual network.the whole cluster acts like one computer now.

        in production we have a backup for master node.

    Main k8 components:
        Node and Pod:
            Node is a machine/vm  
            Pod is a smallest unit in k8,it is an abstraction over container.
            Pod creates a layer on top of container.
            As k8 wants to abstracts away container technology.
            so the tech can be replaced.
            so you only interact with k8 layer.
            usually 1 application per container,you can run multiple in a pod.
        
            k8 offers virtual network,hence each pod gets its own ip address,not the container but pod gets an ip address.

            pods can die easily,and new one gets created with new ip address.
                so we have a Service component to keep network consistent.
        Service and Ingress:
            Service is a permanent Ip address that can be attached to a pod.
            Each pod has its own service to connect to other pods.
            LifeCycle of pod and Service are not conneted.
        
        to make our application accessible via public browser.
            Ingress component takes care of that,it forwards requests from public to cluster

        ConfigMap component to take care of configurations.
            external configurations here,like urls of databases etc.
        
        secret component is like ConfigMap but is for secret configurations.

        
        VOLUMES:
            if database pod gets restared,data is gone.
            volumes attaches a physical storage to a pod,the storage could be in cloud or anywhere,it is not part of cluster,we just reference it.
        
        Everything is replicated on multiple servers.
            service is also a load balancer,replicas are connected to same Service.
            you just put in config,how many replicas you want,that config is called deployment.

            in practise we work with deployments.
            we can scale up and scale down.
            Deployment is abstraction on top of Pods.
            if one replica dies,another one takes care of whole.
            
            DB cannot be replicated with deployments as they have state.
                STATEFULSET takes care of such applications,they are not created using Deployment.
                it is not easy task.
                so DB are often outside the cluster and we just communicate to it.

    k8 configuration:
        all configurations go via master node and its api server.
        client could be ui,or api,or cli like kubectl,they send their requests to master node.

        the requests have to be in yaml format or json format.
        these configurations are declarative.

        there are configuration files for deployments and Services.

        each config has metadata  and specifications and status , and status is automatically generated by k8,and k8 uses state to check if Everything is fine.etcd is where status comes from.

        nginx-deployment.yaml                                     nginx-service.yaml

        apiVersion: app/v1                                         apiVersion: v1
        kind: Deployment                                           kind: Service
        metadata:                                                  metadata:
            name: nginx-deployment                                     name: nignx-service 
        spec:                                                      spec:
            replicas: 2

        yaml is strick about indentation.

        usual practise is to store config files with application code.
        or you can have git repository for code.


    cluster setup:
        minikube is a one node cluster for practise.
        install minikube,as docker container or vm
        minikube start --driver docker 
        minikube status 
        kubectl gets installed as dependency.

        kubectl get node #displays all nodes 

    kubectl:
        cli to interact with cluster,it talks to api server in master node.

    configurations:
 
        mongo-config.yaml

            apiVersion: v1
            kind: ConfigMap
            metadata:
                name: mongo-config 
            data:
                mongo-url: mongo-service
            
        mongo-secret.yaml
            apiVersion: v1
            kind: Secret
            metadata:
                name: mongo-secret 
            type: Opaque 
            data:
                USER_NAME: ytrwdkjdh
                PASSWORD: mfhdhfdhfhdhfghfdhfdjf
            

        we can reference any of these values in deployments.

        mongo.yaml for deployment and Service.template is configuration for pods it has its own spec metadata 
            apiVersion: apps/v1
            kind: Deployment
            metadata:
                name: nginx-deployment
                labels:
                    app:nginx
            spec:
                replicas:3
                selector:
                    matchLabel:
                        app: nginx 

            template:
                metadata:
                    labels:
                        app: nginx 
                spec:
                    container:
                    -name: nginx 
                     image: mongo:1.4.2
                     ports:
                     - containerPort: 27017
        ---
        here service configurations
        apiVersion: v1
        kind: Service
        metadata:
            name: webapp
        spec:
            selector:
                app: webapp
        ports:
            - protocol: TCP
              port: 3000
              targetPort: 27017


    kubectl get pod to see pods 
    kubectl apply -f abc.yaml
    it creates deployment and service 

    kubectl get all   # it shows all components.
    kubectl get pod
    kubectl help 
    kubctl get --help

    kubectl get svc  to see ports and ip to access it.
    